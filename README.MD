# Big O Notation Playground

## ğŸ“š Introduction

This playground is my personal space to explore and understand Big O notation. Here, I experiment with how Big O works and learn to apply it in real-world programming scenarios.

## ğŸ§® What is Big O Notation?

Big O notation characterizes functions according to their growth rates. Different algorithms may be more efficient in different situations. Understanding Big O helps you choose the right algorithm for your specific needs.

| Notation   | Name         | Description                                            |
| ---------- | ------------ | ------------------------------------------------------ |
| O(1)       | Constant     | Execution time stays the same regardless of input size |
| O(log n)   | Logarithmic  | Execution time grows logarithmically with input size   |
| O(n)       | Linear       | Execution time grows linearly with input size          |
| O(n log n) | Linearithmic | Combination of linear and logarithmic growth           |
| O(nÂ²)      | Quadratic    | Execution time grows quadratically with input size     |

## ğŸ—‚ï¸ Project Structure

```
â”œâ”€â”€ golang/
â”‚   â”œâ”€â”€ main.go                     # Main entry point for Go examples
â”‚   â”œâ”€â”€ 1-o1/                       # O(1) - Constant time
â”‚   â”‚   â””â”€â”€ 1-O1_constant.go
â”‚   â”œâ”€â”€ 2-ologn/                    # O(log n) - Logarithmic time
â”‚   â”‚   â””â”€â”€ 2-OlogN_binary_search.go
â”‚   â”œâ”€â”€ 3-on/                       # O(n) - Linear time
â”‚   â”‚   â””â”€â”€ 3-On_linear_scan.go
â”‚   â”œâ”€â”€ 4-onlogn/                   # O(n log n) - Linearithmic time
â”‚   â”‚   â””â”€â”€ 4-OnLogN_merge_sort.go
â”‚   â””â”€â”€ 5-on2/                      # O(nÂ²) - Quadratic time
â”‚       â””â”€â”€ 5-On2_naive_pairs.go
â”œâ”€â”€ javascript/
â”‚   â”œâ”€â”€ 1-O1_constant.js            # O(1) - Constant time example
â”‚   â”œâ”€â”€ 2-OlogN_binary_search.js    # O(log n) - Logarithmic time example
â”‚   â”œâ”€â”€ 3-On_linear_scan.js         # O(n) - Linear time example
â”‚   â”œâ”€â”€ 4-OnLogN_merge_sort.js      # O(n log n) - Linearithmic time example
â”‚   â””â”€â”€ 5-On2_naive_pairs.js        # O(nÂ²) - Quadratic time example
â”œâ”€â”€ php/
â”‚   â”œâ”€â”€ 1-O1_constant.php           # O(1) - Constant time example
â”‚   â”œâ”€â”€ 2-OlogN_binary_search.php   # O(log n) - Logarithmic time example
â”‚   â”œâ”€â”€ 3-On_linear_scan.php        # O(n) - Linear time example
â”‚   â”œâ”€â”€ 4-OnLogN_merge_sort.php     # O(n log n) - Linearithmic time example
â”‚   â””â”€â”€ 5-On2_naive_pairs.php       # O(nÂ²) - Quadratic time example
â”œâ”€â”€ info/
â”‚   â”œâ”€â”€ big-o-notation-graph.png
â”‚   â”œâ”€â”€ big-o-notation-table_data_structure.png
â”‚   â””â”€â”€ big-o-notation-array_sorting.png
â””â”€â”€ README.md
```

## ğŸš€ Getting Started

### Prerequisites

- Node.js (version 20 or higher) for JavaScript examples
- PHP (version 8.1 or higher) for PHP examples
- Go (version 1.20 or higher) for Go examples

## ğŸ” How to Use the Playground

Run each example to observe how different algorithms perform with the same input size:

```bash
# Javascript
node javascript/1-O1_constant.js
node javascript/2-OlogN_binary_search.js
node javascript/3-On_linear_scan.js
node javascript/4-OnLogN_merge_sort.js
node javascript/5-On2_naive_pairs.js

# Golang
GO111MODULE=off go run golang/main.go o1
GO111MODULE=off go run golang/main.go ologn
GO111MODULE=off go run golang/main.go on
GO111MODULE=off go run golang/main.go onlogn
GO111MODULE=off go run golang/main.go on2
GO111MODULE=off go run golang/main.go all

# PHP ( Coming Soon )
php php/1-O1_constant.php
php php/2-OlogN_binary_search.php
php php/3-On_linear_scan.php
php php/4-OnLogN_merge_sort.php
php php/5-On2_naive_pairs.php

```

### Experiment with Different Input Sizes

To truly understand Big O notation, try modifying the N value in each script (make it 10Ã— bigger or smaller) and observe how the execution time changes:

- O(1) : Execution time barely changes regardless of input size
- O(log n) : Execution time grows very slowly (doubling N only adds one more iteration)
- O(n) : Execution time doubles when input size doubles
- O(n log n) : Execution time grows slightly faster than linear (watch what happens when you compare 100k vs 200k elements)
- O(nÂ²) : Execution time grows dramatically (doubling N makes it approximately 4Ã— slower)

## ğŸ§  Why Big O Matters

Understanding Big O notation helps you:

1. Predict Performance : Anticipate how your code will perform with large inputs
2. Compare Algorithms : Choose the most efficient solution for your specific problem
3. Optimize Code : Identify and eliminate inefficient patterns in your code
4. Technical Interviews : Discuss algorithm efficiency in a standardized way

## ğŸ“– Reference & Further Learning

- Big O Cheat Sheet [ENG] : [Big O Notation - Know Thy Complexities!](https://www.bigocheatsheet.com/)
- Freecodecamp [ENG] : [Big O Notation: Why It Matters and Why It Doesn't](https://www.freecodecamp.org/news/big-o-notation-why-it-matters-and-why-it-doesnt-1674cfa8a23c/)
- Backend Magang [IND] : [Big O Notation - Memahami Kompleksitas Algoritma dalam Pemrograman](https://www.youtube.com/watch?v=XgKfcZctwA8)

## ğŸ‘¨â€ğŸ’» Author

Created with ğŸ’» by Ignata

- ğŸ“‚ GitHub: [Aldo Ignata Chandra](https://github.com/aldoignatachandra)
- ğŸ’¼ LinkedIn: [Aldo Ignata Chandra](https://linkedin.com/in/aldoignatachandra)
